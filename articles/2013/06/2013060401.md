title: 这两天用js和html5写游戏遇到的一些事情
date: 2013-06-04 00:08:30
---

canvas当然能做3d，不过既然做2d就遇到一个重要的问题就是贴图的问题，我这个是小游戏，全屏刷新之类的效率也不会太低，不过canvas贴图有一个问题，就是图不能转。一般的库例如qt之类的，图片都有旋转的能力，不过canvas不行啊，html的image对象其实就是&lt;img&gt;标签而已，根本不能旋转，也不能说写个css3进去旋转……那怎么办呢。这个我觉得是不是就是因为这样，所以canvas的开发者研究出来了……图片不转我转的功能，canvas自己能转，所以画一个图就要变成canvas转，画图，canvas转回来，这样的过程，代码如下：

canvas = document.getElementById("MainCanvas");
ctx = this.canvas.getContext("2d");

var x = 100;
var y = 100;
var w = 300;
var h = 200;

ctx.save();

ctx.translate(x, y);
ctx.translate(w/2, this.h/2);
ctx.rotate(0.8);

//这里是以画矩形为例的，如果是画图片可以改成
//drawImage(image, 0, 0, w, h, x, y, w, h);//w和h就是image.width和image.height,0是不变的
ctx.fillStyle="blue";
ctx.fillRect(0 - w/2, 0 - h/2, w, h);

ctx.restore();

//这个红色小矩形代表的是原来图片的中心点
ctx.fillStyle="red";
ctx.fillRect(x + w/2 - 1, y + h/2 - 1,2,2);

还有遇到一个问题就是游戏的碰撞检测的问题，2d游戏子弹打中自然要有碰撞检测了，png图片没有的地方是透明的额，比较方便进行碰撞的检测。我的方法并不一定是最好的，可能是最笨的，只是记录一下。首先图片都算是矩形，进行矩形碰撞检测，减少像素检测的工作量，这个很简单就不说了。下面只说像素检测的。

首先把图片1画到一个canvas上，然后检测这个canvas的像素数 ，然后擦除canvas里的内容。然后把图片2画到canvas上，计算像素数，然后擦除。最后把图片1和2都画在canvas上，然后检测像素数。这样我们就得到了三个像素数的量，如果第一个量加上第二个量等于第三个，就代表没碰着，反之如果小于，就代表碰撞了，理论上不会有大于的情况。

之后我发现检测一个完整的canvas像素数太费时了，最后变成检测图片1和图片2，各自其实也可以算是一个矩形（只是部分像素为透明），然后能容下这两个矩形的最小的矩形，对这个矩形进行像素计算。因为像素检测是在矩形检测之后，所以这个工作量已经变得比较少了。（或许能改进算法，只检测两个图片矩形各自中心点所组成的矩形？谁知道呢）

这部分最后说一下canvas的像素计算的问题，首先是用getContext("2d")得到一个ctx，然后用getImageData（x,y,w,h）得到一个数组，这个数组每4个元素为一个像素的内容，这4个元素数值分别是三原色和透明度的值，我只检测透明度，所以我只检测这个数组3、7、11……的元素位置的内容是否为0。

吐槽一下html5的声音的问题，太恶心了，不仅仅是各个浏览器对声音支持不一致，甚至同一浏览器对不同声音格式的支持都不一致。我写一个玩家发射子弹和敌方或者玩家飞机爆炸的声音，这两个声音在IE10和chrome都比较完美，尤其是IE特别完美让我很惊讶，不过在FF上非常糟糕，声音输出方式完全和IE和Chrome不一样……这是搞什么啊。

还有一个问题是关于chrome的一个问题，就是我写游戏是本地文件直接打开的，但是chrome有个安全设置，就是它会把我检测像素碰撞时候的canvas当做“外来物”，貌似官方叫“tainted canvas”，对这个不能进行getImageData，控制台会提示安全错误。还有一个问题就是chrome不允许“画”canvas，就是其实canvas的drawImage在IE和FF里是能把另一个canvas（注意不是getContext来的ctx）当做图片draw出来，可是chrome不许这么做，只能draw一个真的image对象，很奇怪。