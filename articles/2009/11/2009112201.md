title: 关于CPU和布尔代数（boolean），本来我想写一个好的科普文字的，但是显然没那么容易……
date: 2009-11-22 13:12:00
---

CPU的全名是Central Process Unit，即中央处理器，它在电脑中扮演者最重要的角色。但是它到底做什么事情呢？你可以用电脑处理多媒体信息，玩游戏，上网，等等都必须有CPU的参与，但是实际上CPU所做的工作仅仅是计算。
CPU的设计思想最初就来源于对逻辑的研究，而其中最重要的应该就是布尔代数。布尔代数是一个由简单规则组成的逻辑模型，我们知道逻辑中最基础的概念就是命题，而根据排中律，命题如果不是真的，就应该是假的，假设有如下命题：
地球是椭圆的
苹果是一种水果
他们都是真命题，那么如果我们用一个词"并且"把这两个命题连接起来：
"地球是椭圆的"并且"苹果是一种水果"
我们说这个命题依然是一个真命题，但是如果我有另一个命题：
苹果不是一种水果
显然这是一个假命题，那么我们还用刚才那个词连接它会怎么样？：
"地球是椭圆的"并且"苹果不是一种水果"
显然这不是一个真命题，因为组合这个命题的第二个命题是假的，所以导致这整句话都是假的。在计算机科学中我们常常把这个"并且"操作称作"and"或者"与"，它有如下的性质：
真 and 真 = 真
真 and 假 = 假
假 and 真 = 假
假 and 假 = 假
and是布尔代数的基本操作之一。另一个最基本的操作就是"或者"，它的意思是它所连接的两条命题中如果有一条是真的，那么我们就说我们连接起来的命题是真的：
"地球是椭圆的"或者"苹果不是一种水果"
我们最常用的例子就是：
"苹果是一种水果"或者"苹果不是一种水果"
这条命题总是真的，因为要么苹果是的，要么不是，也就是说它俱有如下的性质，我们一般把"或者"称作"or"：
真 or 真 = 真
真 or 假 = 真
假 or 真 = 真
假 or 假 = 假
布尔代数的最后一个基本操作我们可以简单的称其为"不对"，如果我们把它加在真命题上会怎么样：
"苹果是一种水果"不对
也就是说这个命题变成了假的，如果我们把它加在假命题上相反，假命题就会变成真的，我们一般用"not"代表"不对"，也可以说是取反的操作。
最终科学家发现，虽然布尔代数针对的是逻辑，但是如果把"真"看做是"1"，把假看做是"0"，那么我们竟然可以使用布尔代数进行基于2进制的数学运算。我们人类最常用的就是十进制，这并不是理所当然的，或者说这应该和我们有十个手指有关，而如果我们有两个手指怎么办，我们只能表示"0"和"1"，那么我们怎么表示2呢？我们只要进位就可以了，十进制是逢10进1，而二进制就是逢2进1，这确实可行：
1（十进制），1（二进制）
2（十进制），10（二进制）
3，11
4，100
5，101
6，110
……
让我们设想一下二进制的一位加法，1+1=10，个位是0，1+0=1，0+1=1，0+0=0，也就是说如果两个加数相同，那么这一位就是0，并且有向高位的进位，如果不相同，那么就是1，我们如何设计这样一个运算呢，假设a和b为两个加数：
（a and （not b））or（（not a） and b）
我们把这个操作称为"异或"或者"xor"，它具有如下的性质：
1 xor 1 = 0
1 xor 0 = 1
0 xor 1 = 1
0 xor 0 = 0
也就是说，不同的输入会得到1，相同的会得到0，通过它我们就能设计出1位的二进制加法，如果是多位的呢，那么我们显然需要进位，但是那已经非常简单，我们只要让进位c = （a and b）or（a and c）or（b and c）就可以了，因为只有a，b，c中有两个1的时候，进位才产生（c是从低位来的进位，在第一位的时候我们不妨将c设为0）。那么我们的加法也要改变，因为我们要考虑进位c：
（a and b and c）or （（not a） and （not b） and c）or（（not a） and b and （not c））or（a and （not b） and （not c））
这个式子显然很复杂，但是我们可以通过布尔代数进行缩减，无论如何我们将这样的运算单元进行多级串联之后，我们就得到了多位二进制加法的计算器。